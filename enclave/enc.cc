// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#include <stdio.h>
#include <openssl/evp.h>
#include <string>
#include <unordered_map>

#include "crypto.hpp"
#include "config.h"
#include "logging.hpp"

// Include the trusted dcr_proxy header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the dcr_proxy.edl file.
#include "dcr_proxy_t.h"

// This is the function that the host calls. It prints
// a message in the enclave before calling back out to
// the host to print a message from there too.
const char *c_hmac_key = "1234567890";
unsigned int c_klen = 11;

const char *s_hmac_key = "0123456789";
unsigned int s_klen = 11;

std::unordered_map<std::string, int> *recv_ack_map = new std::unordered_map<std::string, int>;

bool enc_handle_write(
    const char *msg, unsigned int msg_len,
    const char *c_digest_in,
    char *s_digest_out)
{
    bool ret = true;
    // verify if received client's hmac is valid
    std::string c_digest_expected = hmac_sha256(c_hmac_key, c_klen, msg, msg_len);

    if (std::strcmp(c_digest_expected.c_str(), c_digest_in) == 0)
    {
        Logger::log(LogLevel::DEBUG, "[HMAC] HMAC verification successful for msg: " + (std::string)msg);
    }
    else
    {
        Logger::log(LogLevel::DEBUG,
                    "[HMAC] HMAC verification failed for msg: " + (std::string)msg +
                        "\n Expected: " + c_digest_expected +
                        "\n Received: " + (std::string)c_digest_in);

        ret = false;
    }

    // generate server's hmac
    std::string s_digest = hmac_sha256(s_hmac_key, s_klen, msg, msg_len);
    std::strcpy(s_digest_out, s_digest.c_str());

    return ret;
}

bool enc_handle_ack(
    const char *msg, unsigned int msg_len,
    const char *s_digest_in,
    char *c_digest_out)
{
    bool ret = false; // return true only if quorum is achieved

    // verify if received server's hmac is valid
    std::string s_digest_expected = hmac_sha256(s_hmac_key, s_klen, msg, msg_len);

    if (std::strcmp(s_digest_expected.c_str(), s_digest_in) == 0)
    {
        Logger::log(LogLevel::DEBUG, "[HMAC] HMAC verification successful for ack: " + (std::string)msg);
    }
    else
    {
        Logger::log(LogLevel::DEBUG,
                    "[HMAC] HMAC verification failed for msg: " + (std::string)msg +
                        "\n Expected: " + s_digest_expected +
                        "\n Received: " + (std::string)s_digest_in);
    }

    (*recv_ack_map)[(std::string)msg] += 1;
    if ((*recv_ack_map)[(std::string)msg] == WRITE_THRESHOLD)
    {
        Logger::log(LogLevel::DEBUG, "[DC Proxy] ack message reached quorum for hash: " + (std::string)msg);
        ret = true;
    }

    // generate client's hmac
    std::string c_digest = hmac_sha256(c_hmac_key, c_klen, msg, msg_len);
    std::strcpy(c_digest_out, c_digest.c_str());

    return ret;
}