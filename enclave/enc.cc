// Copyright (c) Open Enclave SDK contributors.
// Licensed under the MIT License.

#include <stdio.h>
#include <openssl/evp.h>
#include <string>

#include "crypto.hpp"
#include "logging.hpp"

// Include the trusted dcr_proxy header that is generated
// during the build. This file is generated by calling the
// sdk tool oeedger8r against the dcr_proxy.edl file.
#include "dcr_proxy_t.h"

// This is the function that the host calls. It prints
// a message in the enclave before calling back out to
// the host to print a message from there too.
const char* c_hmac_key = "1234567890";
unsigned int c_klen = 11;

const char* s_hmac_key = "0123456789";
unsigned int s_klen = 11;
void enclave_dcr_proxy()
{
    // Print a message from the enclave. Note that this
    // does not directly call fprintf, but calls into the
    // host and calls fprintf from there. This is because
    // the fprintf function is not part of the enclave
    // as it requires support from the kernel.
    fprintf(stdout, "Host called into enclave to print: Running enclave code!\n");

    // Call back into the host
    oe_result_t result = host_dcr_proxy();
    if (result != OE_OK)
    {
        fprintf(
            stderr,
            "Call to host_dcr_proxy failed: result=%u (%s)\n",
            result,
            oe_result_str(result));
    }
}

bool enc_handle_write(
    const char* msg, unsigned int msg_len, 
    const char* c_digest_in,
    char* s_digest_out)
{
    bool ret = true;
    // verify if received client's hmac is valid
    std::string c_digest_expected = hmac_sha256(c_hmac_key, c_klen, msg, msg_len);

    if (std::strcmp(c_digest_expected.c_str(), c_digest_in) == 0)
    {
        Logger::log(LogLevel::DEBUG, "[HMAC] HMAC verification successful for msg: " + (std::string) msg);
    }
    else
    {
        Logger::log(LogLevel::DEBUG, 
            "[HMAC] HMAC verification failed for msg: " + (std::string) msg +
            "\n Expected: " + c_digest_expected +
            "\n Received: " + (std::string) c_digest_in
        );
        
        ret = false;
    }

    // generate server's hmac
    std::string s_digest = hmac_sha256(s_hmac_key, s_klen, msg, msg_len);
    std::strcpy(s_digest_out, s_digest.c_str());
    
    return ret;
}

void enc_handle_ack(const char* msg)
{
    fprintf(stdout, "enc_handle_ack called\n");
    return;
}